(***********************************************************************                    Mathematica-Compatible NotebookThis notebook can be used on any computer system with Mathematica 3.0,MathReader 3.0, or any compatible application. The data for the notebook starts with the line of stars above.To get the notebook into a Mathematica-compatible application, do one of the following:* Save the data starting with the line of stars above into a file  with a name ending in .nb, then open the file inside the application;* Copy the data starting with the line of stars above to the  clipboard, then use the Paste menu command inside the application.Data for notebooks contains only printable 7-bit ASCII and can besent directly in email or through ftp in text mode.  Newlines can beCR, LF or CRLF (Unix, Macintosh or MS-DOS style).NOTE: If you modify the data for this notebook not in a Mathematica-compatible application, you must delete the line below containing the word CacheID, otherwise Mathematica-compatible applications may try to use invalid cache data.For more information on notebooks and Mathematica-compatible applications, contact Wolfram Research:  web: http://www.wolfram.com  email: info@wolfram.com  phone: +1-217-398-0700 (U.S.)Notebook reader applications are available free of charge from Wolfram Research.***********************************************************************)(*CacheID: 232*)(*NotebookFileLineBreakTestNotebookFileLineBreakTest*)(*NotebookOptionsPosition[     14714,        286]*)(*NotebookOutlinePosition[     15557,        313]*)(*  CellTagsIndexPosition[     15513,        309]*)(*WindowFrame->Normal*)Notebook[{Cell[BoxData[{    \( (*\  : Name : \ JuliaSet`\ *) \n (*\ \( : Author : \ Mark\ McClure\),       \ April\ 1998\ *) \n (*\ \( : Copyright : \ Copyright\ Mark\ McClure\),       \ 1998\ *) \n (*\  : Package\ \(Version : \ 1.1\)\ *) \n (*      \  : Mathematica\ \(Version : \ 2.2\)\ *) \n (*      \  : Summary : \n\t          Generates\ images\ of\ Julia\ sets\ using\ several\n\tvariants\ of\             the\ inverse\ iteration\ \(algorithm . \)\ \n*) \n\n    BeginPackage["\<JuliaSet`\>"]\n\),     \(Needs["\<Utilities`FilterOptions`\>"]\n\),     \(JuliaSet::usage\  = \ "\<JuliaSet is a package containing severalimplementations of inverse iteration algorithms for thegeneration of Julia sets.\>"\n\),     \(Julia::usage\  = \ "\<Julia[formula,var] generates the Julia set of the rational function defined by formula, using the modified inverse iteration algorithm.\>"\n\ \),     \(JuliaSimple::usage\  = \ "\<JuliaSimple[c,depth] generates 2^depth points of the Julia set for z^2 + c using a simple deterministic algorithm.\>"\n\ \t\),     \(JuliaModified::usage\  = \ "\<JuliaModified[c] generates the Julia set for z^2 + c using a modified determinstic algorithm.\>"\n\),     \(JuliaStochastic::usage\  = \ "\<JuliaStochastic[c,numpoints] generates numpoints points of the Julia set for z^2 + c using a stochasticalgorithm.\>"\n\),     \(Resolution::usage\  = \ "\<Resolution is a positive integer valued Option of Julia and JuliaModified which controls the level of detail of the generated set.\>"\n\),     \(Bound::usage\  = \ "\<Bound is a positive real valued Option of Julia which specifies the maximum absolute vale of pointsplotted in the Julia set of a rational function.\>"\n\),     \(OneBias::usage\  = \ "\<OneBias is an Option of JuliaStochastic which determines the probability of choosing the positive inverse of z^2 + c.  OneBias must be a real number stricly between 0 and 1.\>"\n\ \t\),     \(Begin["\<`Private`\>"]\n\n (*\ Set\ the\ Options\ *) \n    \n (*\ For\ JuliaSimple\ *) \),     \(JuliaSimpleOptions\  = \       Join[{AspectRatio\  -> \ Automatic, \ Axes\  -> \ False, \n\t\t          PlotStyle\  -> \ {AbsolutePointSize[0.4]}}, \ Options[ListPlot]]; \n    keywords\  = \       Complement[Union[First\ /@\ JuliaSimpleOptions], \ \n        \t{DisplayFunction, \ DefaultFont}]; \n    vals\  = \ keywords\  /. \ \ JuliaSimpleOptions; \n    special\  =       \ {DisplayFunction\  :> \ $DisplayFunction, \         DefaultFont\  :> \ $DefaultFont}; \n    Options[JuliaSimple]\  = \       Union[Apply[Rule, Transpose[{keywords, vals}], {1}], \n\tspecial]; \n    \n (*\ For\ JuliaModified\ *) \n    Options[JuliaStochastic]\  = \       Join[{OneBias\  -> \  .5}, \ Options[JuliaSimple]]; \n    Options[JuliaModified]\  = \       Join[{Resolution\  -> \ 200}, \ Options[JuliaSimple]]; \n    Options[Julia]\ \ \ \  = \       Join[{Bound\  -> \ 4}, \ Options[JuliaModified]]; \n\n    \n (*\ The\ functions\ *) \n\n (*\ Error\ Messages\ *) \n    JuliaSet::argu\  = \ "\<`1` called with `2`; `3` expected.\>"\),     \(JuliaSet::badNumber\  = \       "\<Number expected at position 1 in `1`.\>"\),     \(JuliaSet::badInt\  = \       "\<Positive Integer expected at position 2 in `1`.\>"\),     \(JuliaSet::badOpt\  = \       "\<Options expected as optional arguments in `1`.\>"\),     \(JuliaSet::optx\  = \ "\<Unknown Option `1`.\>"\),     \(Julia::badFormula\  = \ "\<Rational function of degree at least two expected at position 1 in `1`.\>"\),     \(Julia::noInverses\  = \ "\<Can't find the the inverse functions.\>"\),     \(OneBias::outOfRange\  = \       "\<OneBias must be stricly between 0 and 1. Using 0.5.\>"\),     \(Resolution::outOfRange\  = \       "\<Resolution must be a positive integer.  Using 200.\>"\),     \(Bound::outOfRange\  = \       "\<Bound must be a positive number.  Using 4.\>"\n\n\),     \(JuliaSimple[c_, \ depth_, \ opts___]\  := \       Module[\n\t{invImage, \ points, \             valid\  = \ First\ /@\ Options[JuliaSimple]}, \n\t\n\t          Scan[If[\(! MemberQ[valid, \ First[#]]\), \n\t\t                Message[JuliaSet::optx, \ ToString[First[#]]]]&, \n\t\t            Flatten[{opts}]\n\t]; \n\t\n\t          invImage\  := \ \n\t\t            \((\ \(N[{1, \(-1\)}\ Sqrt[# - c]]&\)\ /@\ #\  // \ Flatten\ )                \)\ &; \n\t          points\  = \             \({Re[#], \ Im[#]}&\)\ /@\ Nest[invImage, \ {1}, \ depth]; \n\t          ListPlot[points, \ \n\t\tFilterOptions[ListPlot, opts], \ \n\t\t            FilterOptions[ListPlot, Sequence\ @@\ Options[JuliaSimple]]\n\t]            \n]\  /; \ \ \n\ \         \((\ NumberQ[N[c]]\  || \               Message[JuliaSet::badNumber, \ JuliaSimple, \ c]\ )\)\  && \n\t          \((\ \((IntegerQ[depth]\  && \ depth\  > \ 0\ )\)\  || \n\t\               Message[JuliaSet::badInt, \ JuliaSimple, \ depth]\ )\)\  && \n\t          \((\ And\ @@\ Map[OptionQ, \ {opts}]\  || \n\t\ \ \t              Message[JuliaSet::badOpt, JuliaSimple]\ )\)\n    \n (*\ Special\ cases\ for\ JuliaSimple\ *) \),     \(JuliaSimple[]\ \ \  := \       Message[JuliaSet::argu, \ "\<JuliaSimple\>", \ \n\t"\<0 arguments\>", \         "\<2 arguments are\>"]\),     \(JuliaSimple[c_]\  := \       Message[JuliaSet::argu, \ "\<JuliaSimple\>", \ \n\t"\<1 argument\>",         \ \ "\<2 arguments are\>"]\n\n\),     \(JuliaModified[c_, \ opts___]\  := \       Module[\n\t{invImage, reducedInvImage, pointsSoFar, res, \ \n\t            valid\  = \ First\ /@\ Options[JuliaModified]}, \n\n\t          Scan[If[\(! MemberQ[valid, \ First[#]]\), \n\t\t                Message[JuliaSet::optx, \ ToString[First[#]]]]&, \n            \t\t{opts}\n\t]; \n\n\t          res\  = \             \(Resolution\  /. \ {opts}\)\  /. \ Options[JuliaModified]; \n\t          If[\(! \((IntegerQ[res]\  && \ res > 0)\)\), \n            \t\t{Message[Resolution::outOfRange]; \n\t\t              res\  = \ Resolution\  /. \ Options[JuliaModified]}]; \n\t\n\t          invImage\  := \ \n\t\t            \((\ \(N[{1, \(-1\)}\ Floor[res\ Sqrt[# - c]]/res]&\)\ \ /@\ #                    \  // \ Flatten\ )\)&; \n\t          reducedInvImage[points_]\  := \             Module[{newPoints}, \n\t\t              newPoints\  = \ Complement[invImage[points], \ pointsSoFar]; \n              \t\tpointsSoFar\  = \ Union[newPoints, \ pointsSoFar]; \n\t\t              newPoints]; \n\t\t\n\t          pointsSoFar\  = \ Nest[invImage, \ {1}, \ 5]; \n\t          FixedPoint[reducedInvImage, \ pointsSoFar]; \n\t          ListPlot[\({Re[#], \ Im[#]}&\)\ /@\ pointsSoFar, \ \n\t\t            FilterOptions[ListPlot, opts], \ \n\t\t            FilterOptions[ListPlot, Sequence\ @@\ Options[JuliaModified]]\n\t]            \n]\  /; \ \ \n\t        \((NumberQ[c]\  || \               Message[JuliaSet::badNumber, \ JuliaModified, \ c])\)\  && \n          \ \ \ \ \((\             And\ @@\ Map[OptionQ, \ {opts}]\  || \n\t\ \ \t              Message[JuliaSet::badOpt, JuliaModified]\ )\)\n    \n (*\ Special\ case\ for\ JuliaModified\ *) \),     \(JuliaModified[]\  := \       Message[JuliaSet::argu, \ "\<JuliaModified\>", \ \n\t"\<0 arguments\>",         \ "\<1 argument is\>"]\n\t\n\t\n\),     \(Julia[formula_, \ var_Symbol, \ opts___]\  := \       Module[\n\t{z0, inverses, inverseRules, funcs, image, \n\treducedImage,             pointsSoFar, \ res, bound, \n\t            valid\  = \ First\ /@\ Options[Julia]}, \n\n\t          Scan[If[\(! MemberQ[valid, \ First[#]]\), \n\t\t                Message[JuliaSet::optx, \ ToString[First[#]]]]&, \n            \t\t{opts}\n\t]; \n\n\t          res\  = \ \(Resolution\  /. \ {opts}\)\  /. \ Options[Julia]; \n\t          If[\(! \((IntegerQ[res]\  && \ res > 0)\)\), \n            \t\t{Message[Resolution::outOfRange]; \n\t\t              res\  = \ Resolution\  /. \ Options[Julia]}]; \n\t          bound\  = \ \(Bound\  /. \ {opts}\)\  /. \ Options[Julia]; \n\t          If[\(! \((bound > 0)\)\), \n            \t\t{Message[Bound::outOfRange]; \n\t\t              bound\  = \ Bound\  /. \ Options[Julia]}]; \n\t\n\t          inverseRules\  = \ NSolve[# == formula, var]; \n\t          If[And\ @@\ \(ListQ\ /@\ inverseRules\), \             If[Length[inverseRules]\  > \ 1, \n\t\n\t\t              inverses\  = \ var\  /. \ inverseRules; \n\t\t              funcs\  = \                 Function[anInverse, N[Floor[anInverse\ res]/res]\ &]\ \n                  \t\t\t/@\ inverses; \n\t\t              image\  = \ Flatten[\(Through[funcs[#]]&\)\ /@\ #, 1]&; \n\t\t              If[PolynomialQ[formula, var], \n\t\t\t                reducedImage[points_]\  := \                   Module[{newPoints}, \n\t\t\t\t                    newPoints\  = \ Complement[image[points], \ pointsSoFar];                     \n\t\t\t\t                    pointsSoFar\  = \ Union[newPoints, \ pointsSoFar]; \n                    \t\t\t\tnewPoints], \n\t\t\t                reducedImage[points_]\  := \                   Module[{newPoints}, \n\t\t\t\t                    newPoints\  = \ Complement[image[points], \ pointsSoFar];                     \n\t\t\t\t                    newPoints\  = \                       Select[newPoints, \((N[Abs[#]] <= bound)\)&]; \n\t\t\t\t                    pointsSoFar\  = \ Union[newPoints, \ pointsSoFar]; \n                    \t\t\t\tnewPoints]\n\t\t]; \n\t\t              z0\  = \ N[                  Nest[\(funcs[\([1]\)]\)[\(funcs[\([2]\)]\)[#]]&, \ N[Pi],                     10]]; \n\t\t              pointsSoFar\  = \                 Select[Nest[image, {z0}, 3], \((N[Abs[#]] <= bound)\)&]; \n              \t\tFixedPoint[reducedImage, \ pointsSoFar]; \n\t\t              ListPlot[\({Re[#], Im[#]}&\)\ /@\ pointsSoFar, \ \n\t\t\t                FilterOptions[ListPlot, opts], \ \n\t\t\t                FilterOptions[ListPlot, Sequence\ @@\ Options[JuliaModified]]                  \n\t\t], \n\t\tMessage[Julia::badFormula, \ Julia]], \             Message[Julia::noInverses]\ \n\t]\n]\  /; \         \((NumberQ[N[formula\  /. \ var\  -> \ Pi]]                \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  && \n\t              PolynomialQ[Numerator[Together[formula]], \ var]\ \ \ \  && \n\t              PolynomialQ[Denominator[Together[formula]], \ var])\)\  || \ \n          \tMessage[Julia::badFormula, \ Julia]\n    \n (*\ Special\ cases\ for\ Julia\ *) \),     \(Julia[]\ \ \  := \       Message[JuliaSet::argu, \ "\<Julia\>", \ \n\t"\<0 arguments\>", \         "\<2 arguments are\>"]\),     \(Julia[c_]\  := \       Message[JuliaSet::argu, \ "\<Julia\>", \ \n\t"\<1 argument\>", \ \         "\<2 arguments are\>"]\n\n\n\),     \(JuliaStochastic[c_, \ numpoints_, \ opts___]\  := \       Module[\n\t{inv1, inv2, points, z0, oneBias, chooser, \ \n\t            valid\  = \ First\ /@\ Options[JuliaStochastic]}, \n\t\n\t          Scan[If[\(! MemberQ[valid, \ First[#]]\), \n\t\t                Message[JuliaSet::optx, \ ToString[First[#]]]]&, \n            \t\t{opts}\n\t]; \n\n\t          oneBias\  = \             \(OneBias\  /. \ {opts}\)\  /. \ Options[JuliaStochastic]; \n\t          If[\(! \((0 < oneBias\  && \ oneBias < 1)\)\), \n            \t\t{Message[OneBias::outOfRange]; \n\t\t              oneBias\  = \ OneBias\  /. \ Options[JuliaStochastic]}]; \n\t\n          \tinv1\  = \ N[Sqrt[# - c]]&; \ inv2\  = \ N[\(-Sqrt[# - c]\)]&; \n          \tz0\  = \ Nest[inv1[inv2[#]]&, \ 1, \ 5]; \n\t          points\  = \             ComposeList[              Table[chooser\  = \ Random[]; \n\t\t                If[chooser < oneBias, \ inv1, \ inv2], \ \n\t\t{numpoints}],               \ z0]; \n\t          ListPlot[\({Re[#], Im[#]}&\)\ /@\ points, \ \ \n\t\t            FilterOptions[ListPlot, opts], \ \n\t\t            FilterOptions[ListPlot, Sequence\ @@\ Options[JuliaStochastic]]\n            \t]\n]\  /; \ \ \n\t        \((\ NumberQ[c]\  || \               Message[JuliaSet::badNumber, \ JuliaStochastic, \ c]\ )\)\  &&           \n\t\ \ \((\             \((IntegerQ[numpoints]\  && \ numpoints\  > \ 0\ )\)\  || \n              \t\ \ \tMessage[JuliaSet::badInt, \ JuliaStochastic, \                 numpoints]\ )\)\  && \n\t\ \           \((\ And\ @@\ Map[OptionQ, \ {opts}]\  || \n\t\ \ \t              Message[JuliaSet::badOpt, JuliaStochastic]\ )\)\n\t\ \ \t    \n (*\ Special\ cases\ for\ JuliaStochastic\ *) \),     \(JuliaStochastic[]\ \ \  := \       Message[JuliaSet::argu, \ "\<JuliaStochastic\>", \ \n\t        "\<0 arguments\>", \ "\<2 arguments are\>"]\),     \(JuliaStochastic[c_]\  := \       Message[JuliaSet::argu, \ "\<JuliaStochastic\>", \ \n\t        "\<1 argument\>", \ \ "\<2 arguments are\>"]\n\n\ \ \ \ \ \ \),     \(End[]\ \  (*\ End\ Private\ Context\ *) \n\),     \(Protect[JuliaSet, \ Julia, \ JuliaModified, \ JuliaSimple, \ \n\t      JuliaStochastic, \ Bound, \ Resolution, \ OneBias]\n\),     \(EndPackage[]\n\)}], "Input"]},FrontEndVersion->"Macintosh 3.0",ScreenRectangle->{{0, 1920}, {0, 1060}},WindowSize->{520, 740},WindowMargins->{{462, Automatic}, {Automatic, 97}},MacintoshSystemPageSetup->"\<\00/0001804P000000_@2@?olonh35@9B7`<5:@?l0040004/0B`000003509H04/02d5X5k/02H20@4101P00BL?00400@00000000000000000100000000000000000000000000000002000000@210D00000\>"](***********************************************************************Cached data follows.  If you edit this Notebook file directly, not usingMathematica, you must remove the line containing CacheID at the top of the file.  The cache data will then be recreated when you save this file from within Mathematica.***********************************************************************)(*CellTagsOutlineCellTagsIndex->{}*)(*CellTagsIndexCellTagsIndex->{}*)(*NotebookFileOutlineNotebook[{Cell[1709, 49, 13001, 235, 4875, "Input"]}]*)(***********************************************************************End of Mathematica Notebook file.***********************************************************************)